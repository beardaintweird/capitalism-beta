#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('backend:server');
var http = require('http');
const cards = require('./../cards');
const db    = require('./../models');
/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.Server(app);

/*
===============
SOCKET.IO
===============
*/
const socketio = require('socket.io')
const io = (socketio)(server, {
  origin: '*:*'
});

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);

io.on('connection', (socket) => {
  console.log('a user connected');
  socket.on('joinTable', (table_id) => {
    socket.join(table_id)
    console.log('sockets joining room :D');
    io.to(table_id).emit('hello')
  })
  socket.on('startGame', (players, table_id) => {
    console.log('starting game');
    let deck = cards.makeDeck();
    if(players[0].ranking){
      // consecutive games
      players = players.map(player=>{
        player.isTurn = false;
        player.isDone = false;
        player.hand.cards = [];
        player.previousRanking = player.ranking;
        player.ranking = '';
        return player;
      })
    } else {
      // first game
      players = players.map((player, index) => {
        let obj = {
          username: player,
          previousRanking: '',
          ranking: '',
          number: index,
          hand: {
            cards:[]
          },
          isTurn: false,
          isDone: false,
          hasScummedOut: false
        }
        return obj;
      })
    }
    players = cards.dealRandomly(deck, players)
    if(players[0].ranking){
      players = players.map((player,index)=> {
        player.isTurn = player.ranking === 'President' ? true : false
        player.hand.cards.push(deck[index])
        return player;
      })
    }
    io.to(table_id).emit('cards_dealt', players)
  })
  socket.on('pass', (players, username, played_cards, table_id) => {
    let index = arrayObjectIndexOf(players, username, 'username');
    changeTurns(players, index);
    index = index === players.length -1 ? 0 : ++index;
    if(played_cards.length > 1
        && players[index].username === played_cards[played_cards.length - 1].username){
      played_cards = []
    }
    io.to(table_id).emit('pass_complete', players, played_cards);
  })
  socket.on('play_card', (players, card, username, played_cards, table_id) => {
    let searchTerm = card.title + '' + card.suit;
    // gets player's index
    let playerIndex = arrayObjectIndexOf(players, username, 'username');
    // gets card's index in the player's hand
    let cardIndex = arrayObjectIndexOfTwo(players[playerIndex].hand.cards, searchTerm, 'title', 'suit');
    let played_card = players[playerIndex].hand.cards.splice(cardIndex,1)[0];
    played_cards.push(played_card);
    checkIfPlayerIsDone(players,playerIndex, played_card);
    changeTurns(players, playerIndex, shouldSkip(card,played_cards), table_id);
    io.to(table_id).emit('play_card_complete', players, played_cards);
    if(players.filter(player=>player.isDone).length === players.length){
      io.to(table_id).emit('clear')
      io.to(table_id).emit('game_finished')
    }
  })
  socket.on('bomb', (players, card, username, played_cards, table_id) => {
    let searchTerm = card.title + '' + card.suit;
    // gets player's index
    let playerIndex = arrayObjectIndexOf(players, username, 'username');
    // gets card's index in the player's hand
    let cardIndex = arrayObjectIndexOfTwo(players[playerIndex].hand.cards, searchTerm, 'title', 'suit');
    let played_card = players[playerIndex].hand.cards.splice(cardIndex,1);
    played_cards = [];
    checkIfPlayerIsDone(players, playerIndex, played_card);
    io.to(table_id).emit('bomb_complete', players)
    io.to(table_id).emit('clear')
  })
  socket.on('play_doubles', (players, cards, username, played_cards, table_id) => {
    // enter logic for playing doubles

    // gets player's index
    let playerIndex = arrayObjectIndexOf(players, username, 'username');
    console.log('played cards', played_cards, 'hand', players[playerIndex].hand.cards);
    let played_card;
    for(let i = 0; i < 2; i++){
      let searchTerm = cards[i].title + '' + cards[i].suit;
      // gets card's index in the player's hand
      let cardIndex = arrayObjectIndexOfTwo(players[playerIndex].hand.cards, searchTerm, 'title', 'suit');
      played_card = players[playerIndex].hand.cards.splice(cardIndex,1)[0];
      played_cards.push(played_card);
    }
    console.log('played cards', played_cards, 'hand', players[playerIndex].hand.cards);
    checkIfPlayerIsDone(players, playerIndex, played_card);
    changeTurns(players, playerIndex, false, table_id);
    io.to(table_id).emit('play_doubles_complete', players, played_cards);
  })
  socket.on('play_triples', (players, cards, username, played_cards, table_id) => {
    // enter logic for playing triples
    console.log('playing triples');
    // gets player's index
    let playerIndex = arrayObjectIndexOf(players, username, 'username');
    let played_card;
    for(let i = 0; i < 3; i++){
      let searchTerm = cards[i].title + '' + cards[i].suit;
      // gets card's index in the player's hand
      let cardIndex = arrayObjectIndexOfTwo(players[playerIndex].hand.cards, searchTerm, 'title', 'suit');
      played_card = players[playerIndex].hand.cards.splice(cardIndex,1)[0];
      played_cards.push(played_card);
    }
    checkIfPlayerIsDone(players, playerIndex, played_card);
    changeTurns(players, playerIndex, false, table_id);
    io.to(table_id).emit('play_triples_complete', players, played_cards);
  })
  socket.on('auto_complete', (players, cards, username, played_cards, table_id) => {
    // enter logic for auto completions
    // gets player's index
    let playerIndex = arrayObjectIndexOf(players, username, 'username');
    let played_card;
    for(let i = 0; i < 4; i++){
      let searchTerm = cards[i].title + '' + cards[i].suit;
      // gets card's index in the player's hand
      let cardIndex = arrayObjectIndexOfTwo(players[playerIndex].hand.cards, searchTerm, 'title', 'suit');
      played_card = players[playerIndex].hand.cards.splice(cardIndex,1)[0];
      played_cards.push(played_card);
    }
    checkIfPlayerIsDone(players, playerIndex, played_card);
    changeTurns(players, playerIndex, false, table_id);
    io.to(table_id).emit('play_auto_complete', players, played_cards);
    io.to(table_id).emit('clear')
  })
  socket.on('play_completion', (players, cards, username, played_cards, table_id) => {
    // enter logic for completions
    let playerIndex = arrayObjectIndexOf(players, username, 'username');
    for(let i = 0, len = cards.length; i < len; i++){
      let searchTerm = cards[i].title + '' + cards[i].suit;
      // gets card's index in the player's hand
      let cardIndex = arrayObjectIndexOfTwo(players[playerIndex].hand.cards, searchTerm, 'title', 'suit');
      let played_card = players[playerIndex].hand.cards.splice(cardIndex,1)[0];
      played_cards.push(played_card);
    }
    checkIfPlayerIsDone(players,playerIndex, null);
    changeTurnsForCompletion(players, playerIndex);
    io.to(table_id).emit('completion_complete', players)
    io.to(table_id).emit('clear')
  })
})
// gameplay functions
function shouldSkip(card, played_cards){
  console.log('in should skip');
  // include doubles and triples condition bc there's no skipping with doubles and triples
  // checks if the pile was empty before the last card was played
  if(played_cards.length < 2) return false;
  // checks if the card played is the same rank as the card on top of the pile
  return card.rank === played_cards[played_cards.length - 2].rank;
}
function changeTurns(players, index, shouldSkip, table_id){
  let donePlayers = players.filter((player) => {
    return player.isDone;
  })
  if(donePlayers.length === players.length){
    return;
  }
  players[index].isTurn = false;
  index = index === players.length - 1 ? 0 : ++index;
  while(players[index].isDone){
    index = index === players.length - 1 ? 0 : ++index;
  }
  players[index].isTurn = true;
  if(shouldSkip){
    console.log('skipping player');
    changeTurns(players, index, false, null);
    io.to(table_id).emit('skip');
  }
}
function changeTurnsForCompletion(players, playerIndex){
  players.map((player) => {
    player.isTurn = player.username === players[playerIndex].username ?
      true : false
  })
}
function checkIfPlayerIsDone(players, playerIndex, played_card){
  if(players[playerIndex].hand.cards.length === 0){
    players[playerIndex].isDone = true;
    if(played_card && played_card.rank===13){
        // player scummed out
        addScummedOutToRankings(players,playerIndex);
    } else {
      players = setRankings(players, playerIndex);
    }
  }
}
function setRankings(players, playerIndex){
  let donePlayers = players.filter((player) => {
    return player.isDone;
  })
  // 4 players ranking system
  if(donePlayers.length === 1){
    players[playerIndex].ranking = 'President'
  } else {
    if(donePlayers.filter(player=>player.ranking==='Vice president').length){
      if(donePlayers.filter(player=>player.ranking==='Scum 1').length){
        players[playerIndex].ranking = 'Scum 2'
      } else {
        players[playerIndex].ranking = 'Scum 1'
      }
    } else {
      players[playerIndex].ranking = 'Vice president'
    }
  }
  if(donePlayers.length === players.length - 1){
    let lastPlayer = players.filter(player=>!player.isDone)
    let playerIndex = arrayObjectIndexOf(players, lastPlayer.username, 'username');
    return setRankings(players, playerIndex)
  }
  return players;
}
function addScummedOutToRankings(players, playerIndex){
  // make scum 1 if there is already a scum 2
  if(players.filter(player=>player.ranking === 'Scum 2').length){
    players[playerIndex].ranking = 'Scum 1'
  } else {
    players[playerIndex].ranking = 'Scum 2'
  }
}

// helper functions
function arrayObjectIndexOf(myArray, searchTerm, property) {
    for(var i = 0, len = myArray.length; i < len; i++) {
      if (myArray[i][property] === searchTerm) return i;
    }
    return -1;
}
function arrayObjectIndexOfTwo(myArray, searchTerm, property1, property2) {
    for(var i = 0, len = myArray.length; i < len; i++) {
      let propertyCombo = myArray[i][property1] + '' + myArray[i][property2];
      if (propertyCombo === searchTerm) return i;
    }
    return -1;
}


server.on('error', onError);
server.on('listening', onListening);


/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
