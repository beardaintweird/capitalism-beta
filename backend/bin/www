#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('backend:server');
var http = require('http');
const cards = require('./../cards');
const db    = require('./../models');
/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.Server(app);

/*
===============
SOCKET.IO
===============
*/
const socketio = require('socket.io')
const io = (socketio)(server, {
  origin: '*:*'
});

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);

io.on('connection', (socket) => {
  console.log('a user connected');
  socket.on('joinTable', (table_id) => {
    socket.join(table_id)
    console.log('sockets joining room :D');
    io.to(table_id).emit('hello')
  })
  socket.on('startGame', (players, table_id) => {
    console.log('starting game');
    let deck = cards.makeDeck();

    players = players.map((player, index) => {
      let obj = {
        username: player,
        number: index,
        hand: [],
        isTurn: false,
        isDone: false,
        hasScummedOut: false
      }
      return obj;
    })
    players = cards.dealRandomly(deck, players)
    io.to(table_id).emit('cards_dealt', players)
  })
  socket.on('pass', (players, username, table_id) => {
    console.log('at the beginning of pass', players);
    let index = arrayObjectIndexOf(players, username, 'username');
    console.log('value returned by arrayObjectIndexOf:',index);
    changeTurns(players, index);
    console.log('at the end of pass', players);
    io.to(table_id).emit('pass_complete', players);
  })
  socket.on('play_card', (players, card, username, table_id) => {
    let searchTerm = card.title + '' + card.suit;
    let playerIndex = arrayObjectIndexOf(players, username, 'username');
    let cardIndex = arrayObjectIndexOfTwo(players[playerIndex].hand.cards, searchTerm, 'title', 'suit');
    players[playerIndex].hand.cards.splice(cardIndex,1);
    changeTurns(players, playerIndex);
    io.to(table_id).emit('play_card_complete', players);
  })

})

// helper functions
function arrayObjectIndexOf(myArray, searchTerm, property) {
    for(var i = 0, len = myArray.length; i < len; i++) {
      if (myArray[i][property] === searchTerm) return i;
    }
    return -1;
}
function arrayObjectIndexOfTwo(myArray, searchTerm, property1, property2) {
    for(var i = 0, len = myArray.length; i < len; i++) {
      let propertyCombo = myArray[i][property1] + '' + myArray[i][property2];
      if (propertyCombo === searchTerm) return i;
    }
    return -1;
}
function changeTurns(players, index){
  players[index].isTurn = false;
  index = index === players.length - 1 ? 0 : ++index;
  while(players[index].isDone){
    index = index === players.length - 1 ? 0 : ++index;
  }
  players[index].isTurn = true;
}

server.on('error', onError);
server.on('listening', onListening);


/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
